### 源码中疑惑点
### 不同构建输出的区别与作用
为什么要分 运行时版 与 完整版？首先你要知道一个公式：运行时版 + Compiler = 完整版。也就是说完整版比运行时版多了一个 Compiler，一个将字符串模板编译为 render 函数的家伙，大家想一想：将字符串模板编译为 render 函数的这个过程，是不是一定要在代码运行的时候再去做？当然不是，实际上这个过程在构建的时候就可以完成，这样真正运行的代码就免去了这样一个步骤，提升了性能。同时，将 Compiler 抽离为单独的包，还减小了库的体积。

那么为什么需要完整版呢？说白了就是允许你在代码运行的时候去现场编译模板，在不配合构建工具的情况下可以直接使用，但是更多的时候推荐你配合构建工具使用运行时版本。

除了运行时版与完整版之外，为什么还要输出不同形式的模块的包？比如 cjs、es 和 umd？其中 umd 是使得你可以直接使用 <script> 标签引用Vue的模块形式。但我们使用 Vue 的时候更多的是结合构建工具，比如 webpack 之类的，而 cjs 形式的模块就是为 browserify 和 webpack 1 提供的，他们在加载模块的时候不能直接加载 ES Module。而 webpack2+ 以及 Rollup 是可以直接加载 ES Module 的，所以就有了 es 形式的模块输出。

#### Vue.set()
向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 
注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象
Vue.set()一般用在methods的方法中向已存在的响应式对象中添加新的属性，
不可向data添加新属性，不可在data对象未载入时添加新属性

#### watch和computed的区别
计算属性具有缓存。计算属性是基于它们的依赖进行缓存的。
计算属性只有在它的相关依赖发生改变时才会重新求值。
这就意味着只要 依赖没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。

而侦听器watch是侦听一个特定的值，当该值变化时执行特定的函数。

①从属性名上，computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数。
②从实现上，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算。
watch在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。
③watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。
④watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。



